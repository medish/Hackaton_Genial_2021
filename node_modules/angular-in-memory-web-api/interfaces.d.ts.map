{"version":3,"file":"interfaces.d.ts","sources":["interfaces.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Observable } from 'rxjs';\r\n/**\r\n *  Minimum definition needed by base class\r\n */\r\nexport interface HeadersCore {\r\n    set(name: string, value: string): void | any;\r\n}\r\n/**\r\n* Interface for a class that creates an in-memory database\r\n*\r\n* Its `createDb` method creates a hash of named collections that represents the database\r\n*\r\n* For maximum flexibility, the service may define HTTP method overrides.\r\n* Such methods must match the spelling of an HTTP method in lower case (e.g, \"get\").\r\n* If a request has a matching method, it will be called as in\r\n* `get(info: requestInfo, db: {})` where `db` is the database object described above.\r\n*/\r\nexport declare abstract class InMemoryDbService {\r\n    /**\r\n    * Creates an in-memory \"database\" hash whose keys are collection names\r\n    * and whose values are arrays of collection objects to return or update.\r\n    *\r\n    * returns Observable of the database because could have to create it asynchronously.\r\n    *\r\n    * This method must be safe to call repeatedly.\r\n    * Each time it should return a new object with new arrays containing new item objects.\r\n    * This condition allows the in-memory backend service to mutate the collections\r\n    * and their items without touching the original source data.\r\n    *\r\n    * The in-mem backend service calls this method without a value the first time.\r\n    * The service calls it with the `RequestInfo` when it receives a POST `commands/resetDb` request.\r\n    * Your InMemoryDbService can adjust its behavior accordingly.\r\n    */\r\n    abstract createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}>;\r\n}\r\n/**\r\n* Interface for InMemoryBackend configuration options\r\n*/\r\nexport declare abstract class InMemoryBackendConfigArgs {\r\n    /**\r\n     * The base path to the api, e.g, 'api/'.\r\n     * If not specified than `parseRequestUrl` assumes it is the first path segment in the request.\r\n     */\r\n    apiBase?: string;\r\n    /**\r\n     * false (default) if search match should be case insensitive\r\n     */\r\n    caseSensitiveSearch?: boolean;\r\n    /**\r\n     * false (default) put content directly inside the response body.\r\n     * true: encapsulate content in a `data` property inside the response body, `{ data: ... }`.\r\n     */\r\n    dataEncapsulation?: boolean;\r\n    /**\r\n     * delay (in ms) to simulate latency\r\n     */\r\n    delay?: number;\r\n    /**\r\n     * false (default) should 204 when object-to-delete not found; true: 404\r\n     */\r\n    delete404?: boolean;\r\n    /**\r\n     * host for this service, e.g., 'localhost'\r\n     */\r\n    host?: string;\r\n    /**\r\n     * false (default) should pass unrecognized request URL through to original backend; true: 404\r\n     */\r\n    passThruUnknownUrl?: boolean;\r\n    /**\r\n     * true (default) should NOT return the item (204) after a POST. false: return the item (200).\r\n     */\r\n    post204?: boolean;\r\n    /**\r\n    * false (default) should NOT update existing item with POST. false: OK to update.\r\n    */\r\n    post409?: boolean;\r\n    /**\r\n    * true (default) should NOT return the item (204) after a POST. false: return the item (200).\r\n    */\r\n    put204?: boolean;\r\n    /**\r\n     * false (default) if item not found, create as new item; false: should 404.\r\n     */\r\n    put404?: boolean;\r\n    /**\r\n     * root path _before_ any API call, e.g., ''\r\n     */\r\n    rootPath?: string;\r\n}\r\n/**\r\n*  InMemoryBackendService configuration options\r\n*  Usage:\r\n*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})\r\n*\r\n*  or if providing separately:\r\n*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),\r\n*/\r\nexport declare class InMemoryBackendConfig implements InMemoryBackendConfigArgs {\r\n    constructor(config?: InMemoryBackendConfigArgs);\r\n}\r\n/** Return information (UriInfo) about a URI  */\r\nexport declare function parseUri(str: string): UriInfo;\r\n/**\r\n *\r\n * Interface for the result of the `parseRequestUrl` method:\r\n *   Given URL \"http://localhost:8080/api/customers/42?foo=1 the default implementation returns\r\n *     base: 'api/'\r\n *     collectionName: 'customers'\r\n *     id: '42'\r\n *     query: this.createQuery('foo=1')\r\n *     resourceUrl: 'http://localhost/api/customers/'\r\n */\r\nexport interface ParsedRequestUrl {\r\n    apiBase: string;\r\n    collectionName: string;\r\n    id: string;\r\n    query: Map<string, string[]>;\r\n    resourceUrl: string;\r\n}\r\nexport interface PassThruBackend {\r\n    /**\r\n     * Handle an HTTP request and return an Observable of HTTP response\r\n     * Both the request type and the response type are determined by the supporting HTTP library.\r\n     */\r\n    handle(req: any): Observable<any>;\r\n}\r\nexport declare function removeTrailingSlash(path: string): string;\r\n/**\r\n *  Minimum definition needed by base class\r\n */\r\nexport interface RequestCore {\r\n    url: string;\r\n    urlWithParams?: string;\r\n}\r\n/**\r\n* Interface for object w/ info about the current request url\r\n* extracted from an Http Request.\r\n* Also holds utility methods and configuration data from this service\r\n*/\r\nexport interface RequestInfo {\r\n    req: RequestCore;\r\n    apiBase: string;\r\n    collectionName: string;\r\n    collection: any;\r\n    headers: HeadersCore;\r\n    method: string;\r\n    id: any;\r\n    query: Map<string, string[]>;\r\n    resourceUrl: string;\r\n    url: string;\r\n    utils: RequestInfoUtilities;\r\n}\r\n/**\r\n * Interface for utility methods from this service instance.\r\n * Useful within an HTTP method override\r\n */\r\nexport interface RequestInfoUtilities {\r\n    /**\r\n     * Create a cold response Observable from a factory for ResponseOptions\r\n     * the same way that the in-mem backend service does.\r\n     * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\r\n     * @param withDelay - if true (default), add simulated latency delay from configuration\r\n     */\r\n    createResponse$: (resOptionsFactory: () => ResponseOptions) => Observable<any>;\r\n    /**\r\n     * Find first instance of item in collection by `item.id`\r\n     * @param collection\r\n     * @param id\r\n     */\r\n    findById<T extends {\r\n        id: any;\r\n    }>(collection: T[], id: any): T;\r\n    /** return the current, active configuration which is a blend of defaults and overrides */\r\n    getConfig(): InMemoryBackendConfigArgs;\r\n    /** Get the in-mem service's copy of the \"database\" */\r\n    getDb(): {};\r\n    /** Get JSON body from the request object */\r\n    getJsonBody(req: any): any;\r\n    /** Get location info from a url, even on server where `document` is not defined */\r\n    getLocation(url: string): UriInfo;\r\n    /** Get (or create) the \"real\" backend */\r\n    getPassThruBackend(): PassThruBackend;\r\n    /**\r\n     * return true if can determine that the collection's `item.id` is a number\r\n     * */\r\n    isCollectionIdNumeric<T extends {\r\n        id: any;\r\n    }>(collection: T[], collectionName: string): boolean;\r\n    /**\r\n     * Parses the request URL into a `ParsedRequestUrl` object.\r\n     * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\r\n     */\r\n    parseRequestUrl(url: string): ParsedRequestUrl;\r\n}\r\n/**\r\n * Provide a `responseInterceptor` method of this type in your `inMemDbService` to\r\n * morph the response options created in the `collectionHandler`.\r\n */\r\nexport declare type ResponseInterceptor = (res: ResponseOptions, ri: RequestInfo) => ResponseOptions;\r\nexport interface ResponseOptions {\r\n    /**\r\n     * String, Object, ArrayBuffer or Blob representing the body of the {@link Response}.\r\n     */\r\n    body?: string | Object | ArrayBuffer | Blob;\r\n    /**\r\n     * Response headers\r\n     */\r\n    headers?: HeadersCore;\r\n    /**\r\n     * Http {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html status code}\r\n     * associated with the response.\r\n     */\r\n    status?: number;\r\n    /**\r\n     * Status text for the status code\r\n     */\r\n    statusText?: string;\r\n    /**\r\n     * request url\r\n     */\r\n    url?: string;\r\n}\r\n/** Interface of information about a Uri  */\r\nexport interface UriInfo {\r\n    source: string;\r\n    protocol: string;\r\n    authority: string;\r\n    userInfo: string;\r\n    user: string;\r\n    password: string;\r\n    host: string;\r\n    port: string;\r\n    relative: string;\r\n    path: string;\r\n    directory: string;\r\n    file: string;\r\n    query: string;\r\n    anchor: string;\r\n}\r\n"]}