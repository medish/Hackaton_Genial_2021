/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://localhost:8080";

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface Color {
    "alpha"?: number;
    "blue"?: number;
    "colorSpace"?: ColorSpace;
    "green"?: number;
    "red"?: number;
    "rgb"?: number;
    "transparency"?: number;
}

export interface ColorSpace {
    "csSRGB"?: boolean;
    "numComponents"?: number;
    "type"?: number;
}

export interface ConstraintMatchHardSoftScore {
    "constraintId"?: string;
    "constraintName"?: string;
    "constraintPackage"?: string;
    "identificationString"?: string;
    "justificationList"?: Array<any>;
    "score"?: HardSoftScore;
}

export interface ConstraintMatchTotalHardSoftScore {
    "constraintId"?: string;
    "constraintMatchCount"?: number;
    "constraintMatchSet"?: Array<ConstraintMatchHardSoftScore>;
    "constraintName"?: string;
    "constraintPackage"?: string;
    "constraintWeight"?: HardSoftScore;
    "score"?: HardSoftScore;
}

export interface Course {
    "color"?: Color;
    "degree"?: Degree;
    "id"?: number;
    "name"?: string;
    "professors"?: Array<Professor>;
}

export interface CourseGroup {
    "course"?: Course;
    "duration"?: Duration;
    "groupId"?: number;
    "roomType"?: CourseGroupRoomTypeEnum;
    "size"?: number;
}

export type CourseGroupRoomTypeEnum = "CM" | "TP" | "TD";
export interface CourseGroupOptaPlaner {
    "course"?: Course;
    "dateSlot"?: DateSlot;
    "day"?: CourseGroupOptaPlanerDayEnum;
    "endTime"?: LocalTime;
    "id"?: number;
    "professor"?: Professor;
    "room"?: Room;
    "startTime"?: LocalTime;
}

export type CourseGroupOptaPlanerDayEnum = "MONDAY" | "TUESDAY" | "WEDNESDAY" | "THURSDAY" | "FRIDAY" | "SATURDAY" | "SUNDAY";
export interface CourseSlot {
    "courseGroup"?: CourseGroup;
    "dateSlot"?: DateSlot;
    "endTime"?: LocalTime;
    "professor"?: Professor;
    "room"?: Room;
    "startTime"?: LocalTime;
}

export interface DateSlot {
    "day"?: DateSlotDayEnum;
    "startTime"?: LocalTime;
}


export type DateSlotDayEnum = "MONDAY" | "TUESDAY" | "WEDNESDAY" | "THURSDAY" | "FRIDAY" | "SATURDAY" | "SUNDAY";
export interface Degree {
    "id"?: number;
    "majors"?: Array<Major>;
    "name"?: string;
}

export interface Department {
    "id"?: number;
    "name"?: string;
    "rooms"?: Array<Room>;
}

export interface Duration {
    "nano"?: number;
    "negative"?: boolean;
    "seconds"?: number;
    "units"?: Array<TemporalUnit>;
    "zero"?: boolean;
}

export interface HardSoftScore {
    "feasible"?: boolean;
    "hardScore"?: number;
    "initScore"?: number;
    "softScore"?: number;
    "solutionInitialized"?: boolean;
}

export interface IndictmentHardSoftScore {
    "constraintMatchCount"?: number;
    "constraintMatchSet"?: Array<ConstraintMatchHardSoftScore>;
    "justification"?: any;
    "score"?: HardSoftScore;
}

export interface LocalTime {
    "hour"?: number;
    "minute"?: number;
    "nano"?: number;
    "second"?: number;
}

export interface Major {
    "courses"?: Array<Course>;
    "id"?: number;
    "name"?: string;
}

export interface OptionalCourse {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalCourseGroup {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalCourseSlot {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalDegree {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalDepartment {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalMajor {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalPlanning {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalProfessor {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface OptionalRoom {
    "empty"?: boolean;
    "present"?: boolean;
}

export interface Planning {
    "createdAt"?: Date;
    "id"?: number;
    "name"?: string;
    "slots"?: Array<CourseSlot>;
}

export interface PrecedenceConstraint {
    "id"?: number;
    "priority"?: number;
    "selector"?: string;
    "strict"?: boolean;
    "target"?: string;
    "wants"?: boolean;
    "when"?: string;
}

export interface Professor {
    "email"?: string;
    "firstName"?: string;
    "id"?: number;
    "lastName"?: string;
    "password"?: string;
    "role"?: ProfessorRoleEnum;
}

export type ProfessorRoleEnum = "ADMIN" | "PROFESSOR";
export interface Room {
    "capacity"?: number;
    "name"?: string;
    "roomTypes"?: RoomTypesEnum[];
}

export type RoomTypesEnum = "CM" | "TP" | "TD";
export interface ScoreExplanationTimeTableOptaPlanerHardSoftScore {
    "constraintMatchTotalMap"?: { [key: string]: ConstraintMatchTotalHardSoftScore; };
    "indictmentMap"?: { [key: string]: IndictmentHardSoftScore; };
    "score"?: HardSoftScore;
    "solution"?: TimeTableOptaPlaner;
    "summary"?: string;
}

export interface TemporalUnit {
    "dateBased"?: boolean;
    "duration"?: Duration;
    "durationEstimated"?: boolean;
    "timeBased"?: boolean;
}

export interface TimeConstraint {
    "id"?: number;
    "selector"?: string;
    "wants"?: boolean;
    "dateBegin"?: DateSlot;
    "dateEnd"?: DateSlot;
   "room"?: Room;
    "priority"?: number;
}

export interface TimeTableOptaPlaner {
    "courseGroups"?: Array<CourseGroupOptaPlaner>;
    "dateSlots"?: Array<DateSlot>;
    "rooms"?: Array<Room>;
    "score"?: HardSoftScore;
}

export interface User {
    "email"?: string;
    "firstName"?: string;
    "id"?: number;
    "lastName"?: string;
    "password"?: string;
    "role"?: UserRoleEnum;
}

export type UserRoleEnum = "ADMIN" | "PROFESSOR";


/**
 * AuthcontrollerApi - fetch parameter creator
 */
export const AuthcontrollerApiFetchParamCreactor = {
    /**
     * checkAuth
     * @param username username
     * @param password password
     */
    checkAuthUsingGET(params: {  username: string; password: string; }): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling checkAuthUsingGET");
        }
        // verify required parameter "password" is set
        if (params["password"] == null) {
            throw new Error("Missing required parameter password when calling checkAuthUsingGET");
        }
        const baseUrl = `/signin`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "username": params.username,
            "password": params.password,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * AuthcontrollerApi - functional programming interface
 */
export const AuthcontrollerApiFp = {
    /**
     * checkAuth
     * @param username username
     * @param password password
     */
    checkAuthUsingGET(params: { username: string; password: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = AuthcontrollerApiFetchParamCreactor.checkAuthUsingGET(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthcontrollerApi - object-oriented interface
 */
export class AuthcontrollerApi extends BaseAPI {
    /**
     * checkAuth
     * @param username username
     * @param password password
     */
    checkAuthUsingGET(params: {  username: string; password: string; }) {
        return AuthcontrollerApiFp.checkAuthUsingGET(params)(this.fetch, this.basePath);
    }
};

/**
 * AuthcontrollerApi - factory interface
 */
export const AuthcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * checkAuth
         * @param username username
         * @param password password
         */
        checkAuthUsingGET(params: {  username: string; password: string; }) {
            return AuthcontrollerApiFp.checkAuthUsingGET(params)(fetch, basePath);
        },
    }
};


/**
 * CoursecontrollerApi - fetch parameter creator
 */
export const CoursecontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET(): FetchArgs {
        const baseUrl = `/courses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET");
        }
        const baseUrl = `/courses/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * CoursecontrollerApi - functional programming interface
 */
export const CoursecontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Course>> {
        const fetchArgs = CoursecontrollerApiFetchParamCreactor.getAllUsingGET();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalCourse> {
        const fetchArgs = CoursecontrollerApiFetchParamCreactor.getByIdUsingGET(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CoursecontrollerApi - object-oriented interface
 */
export class CoursecontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET() {
        return CoursecontrollerApiFp.getAllUsingGET()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET(params: {  id: number; }) {
        return CoursecontrollerApiFp.getByIdUsingGET(params)(this.fetch, this.basePath);
    }
};

/**
 * CoursecontrollerApi - factory interface
 */
export const CoursecontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET() {
            return CoursecontrollerApiFp.getAllUsingGET()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET(params: {  id: number; }) {
            return CoursecontrollerApiFp.getByIdUsingGET(params)(fetch, basePath);
        },
    }
};


/**
 * CoursegroupcontrollerApi - fetch parameter creator
 */
export const CoursegroupcontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET1(): FetchArgs {
        const baseUrl = `/courses-groups`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET1(params: {  id: string; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET1");
        }
        const baseUrl = `/courses-groups/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * CoursegroupcontrollerApi - functional programming interface
 */
export const CoursegroupcontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET1(): (fetch: FetchAPI, basePath?: string) => Promise<Array<CourseGroup>> {
        const fetchArgs = CoursegroupcontrollerApiFetchParamCreactor.getAllUsingGET1();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET1(params: { id: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalCourseGroup> {
        const fetchArgs = CoursegroupcontrollerApiFetchParamCreactor.getByIdUsingGET1(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CoursegroupcontrollerApi - object-oriented interface
 */
export class CoursegroupcontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET1() {
        return CoursegroupcontrollerApiFp.getAllUsingGET1()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET1(params: {  id: string; }) {
        return CoursegroupcontrollerApiFp.getByIdUsingGET1(params)(this.fetch, this.basePath);
    }
};

/**
 * CoursegroupcontrollerApi - factory interface
 */
export const CoursegroupcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET1() {
            return CoursegroupcontrollerApiFp.getAllUsingGET1()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET1(params: {  id: string; }) {
            return CoursegroupcontrollerApiFp.getByIdUsingGET1(params)(fetch, basePath);
        },
    }
};


/**
 * CourseslotcontrollerApi - fetch parameter creator
 */
export const CourseslotcontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET2(): FetchArgs {
        const baseUrl = `/courses-slots`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET2(params: {  id: string; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET2");
        }
        const baseUrl = `/courses-slots/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * CourseslotcontrollerApi - functional programming interface
 */
export const CourseslotcontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET2(): (fetch: FetchAPI, basePath?: string) => Promise<Array<CourseSlot>> {
        const fetchArgs = CourseslotcontrollerApiFetchParamCreactor.getAllUsingGET2();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET2(params: { id: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalCourseSlot> {
        const fetchArgs = CourseslotcontrollerApiFetchParamCreactor.getByIdUsingGET2(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CourseslotcontrollerApi - object-oriented interface
 */
export class CourseslotcontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET2() {
        return CourseslotcontrollerApiFp.getAllUsingGET2()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET2(params: {  id: string; }) {
        return CourseslotcontrollerApiFp.getByIdUsingGET2(params)(this.fetch, this.basePath);
    }
};

/**
 * CourseslotcontrollerApi - factory interface
 */
export const CourseslotcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET2() {
            return CourseslotcontrollerApiFp.getAllUsingGET2()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET2(params: {  id: string; }) {
            return CourseslotcontrollerApiFp.getByIdUsingGET2(params)(fetch, basePath);
        },
    }
};


/**
 * DegreecontrollerApi - fetch parameter creator
 */
export const DegreecontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET3(): FetchArgs {
        const baseUrl = `/degrees`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET3(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET3");
        }
        const baseUrl = `/degrees/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * DegreecontrollerApi - functional programming interface
 */
export const DegreecontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET3(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Degree>> {
        const fetchArgs = DegreecontrollerApiFetchParamCreactor.getAllUsingGET3();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET3(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalDegree> {
        const fetchArgs = DegreecontrollerApiFetchParamCreactor.getByIdUsingGET3(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DegreecontrollerApi - object-oriented interface
 */
export class DegreecontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET3() {
        return DegreecontrollerApiFp.getAllUsingGET3()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET3(params: {  id: number; }) {
        return DegreecontrollerApiFp.getByIdUsingGET3(params)(this.fetch, this.basePath);
    }
};

/**
 * DegreecontrollerApi - factory interface
 */
export const DegreecontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET3() {
            return DegreecontrollerApiFp.getAllUsingGET3()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET3(params: {  id: number; }) {
            return DegreecontrollerApiFp.getByIdUsingGET3(params)(fetch, basePath);
        },
    }
};


/**
 * DepartmentcontrollerApi - fetch parameter creator
 */
export const DepartmentcontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET4(): FetchArgs {
        const baseUrl = `/departments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET4(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET4");
        }
        const baseUrl = `/departments/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * DepartmentcontrollerApi - functional programming interface
 */
export const DepartmentcontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET4(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Department>> {
        const fetchArgs = DepartmentcontrollerApiFetchParamCreactor.getAllUsingGET4();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET4(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalDepartment> {
        const fetchArgs = DepartmentcontrollerApiFetchParamCreactor.getByIdUsingGET4(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DepartmentcontrollerApi - object-oriented interface
 */
export class DepartmentcontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET4() {
        return DepartmentcontrollerApiFp.getAllUsingGET4()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET4(params: {  id: number; }) {
        return DepartmentcontrollerApiFp.getByIdUsingGET4(params)(this.fetch, this.basePath);
    }
};

/**
 * DepartmentcontrollerApi - factory interface
 */
export const DepartmentcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET4() {
            return DepartmentcontrollerApiFp.getAllUsingGET4()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET4(params: {  id: number; }) {
            return DepartmentcontrollerApiFp.getByIdUsingGET4(params)(fetch, basePath);
        },
    }
};


/**
 * ErrorcontrollerApi - fetch parameter creator
 */
export const ErrorcontrollerApiFetchParamCreactor = {
    /**
     * errorMessage
     */
    errorMessageUsingDELETE(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingGET(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingHEAD(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "HEAD" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingOPTIONS(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "OPTIONS" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingPATCH(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingPOST(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingPUT(): FetchArgs {
        const baseUrl = `/error`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ErrorcontrollerApi - functional programming interface
 */
export const ErrorcontrollerApiFp = {
    /**
     * errorMessage
     */
    errorMessageUsingDELETE(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingDELETE();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingGET(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingGET();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingHEAD(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingHEAD();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingOPTIONS(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingOPTIONS();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingPATCH(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingPATCH();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingPOST(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingPOST();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * errorMessage
     */
    errorMessageUsingPUT(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ErrorcontrollerApiFetchParamCreactor.errorMessageUsingPUT();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ErrorcontrollerApi - object-oriented interface
 */
export class ErrorcontrollerApi extends BaseAPI {
    /**
     * errorMessage
     */
    errorMessageUsingDELETE() {
        return ErrorcontrollerApiFp.errorMessageUsingDELETE()(this.fetch, this.basePath);
    }
    /**
     * errorMessage
     */
    errorMessageUsingGET() {
        return ErrorcontrollerApiFp.errorMessageUsingGET()(this.fetch, this.basePath);
    }
    /**
     * errorMessage
     */
    errorMessageUsingHEAD() {
        return ErrorcontrollerApiFp.errorMessageUsingHEAD()(this.fetch, this.basePath);
    }
    /**
     * errorMessage
     */
    errorMessageUsingOPTIONS() {
        return ErrorcontrollerApiFp.errorMessageUsingOPTIONS()(this.fetch, this.basePath);
    }
    /**
     * errorMessage
     */
    errorMessageUsingPATCH() {
        return ErrorcontrollerApiFp.errorMessageUsingPATCH()(this.fetch, this.basePath);
    }
    /**
     * errorMessage
     */
    errorMessageUsingPOST() {
        return ErrorcontrollerApiFp.errorMessageUsingPOST()(this.fetch, this.basePath);
    }
    /**
     * errorMessage
     */
    errorMessageUsingPUT() {
        return ErrorcontrollerApiFp.errorMessageUsingPUT()(this.fetch, this.basePath);
    }
};

/**
 * ErrorcontrollerApi - factory interface
 */
export const ErrorcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * errorMessage
         */
        errorMessageUsingDELETE() {
            return ErrorcontrollerApiFp.errorMessageUsingDELETE()(fetch, basePath);
        },
        /**
         * errorMessage
         */
        errorMessageUsingGET() {
            return ErrorcontrollerApiFp.errorMessageUsingGET()(fetch, basePath);
        },
        /**
         * errorMessage
         */
        errorMessageUsingHEAD() {
            return ErrorcontrollerApiFp.errorMessageUsingHEAD()(fetch, basePath);
        },
        /**
         * errorMessage
         */
        errorMessageUsingOPTIONS() {
            return ErrorcontrollerApiFp.errorMessageUsingOPTIONS()(fetch, basePath);
        },
        /**
         * errorMessage
         */
        errorMessageUsingPATCH() {
            return ErrorcontrollerApiFp.errorMessageUsingPATCH()(fetch, basePath);
        },
        /**
         * errorMessage
         */
        errorMessageUsingPOST() {
            return ErrorcontrollerApiFp.errorMessageUsingPOST()(fetch, basePath);
        },
        /**
         * errorMessage
         */
        errorMessageUsingPUT() {
            return ErrorcontrollerApiFp.errorMessageUsingPUT()(fetch, basePath);
        },
    }
};


/**
 * MajorcontrollerApi - fetch parameter creator
 */
export const MajorcontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET5(): FetchArgs {
        const baseUrl = `/majors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET5(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET5");
        }
        const baseUrl = `/majors/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * MajorcontrollerApi - functional programming interface
 */
export const MajorcontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET5(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Major>> {
        const fetchArgs = MajorcontrollerApiFetchParamCreactor.getAllUsingGET5();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET5(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalMajor> {
        const fetchArgs = MajorcontrollerApiFetchParamCreactor.getByIdUsingGET5(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MajorcontrollerApi - object-oriented interface
 */
export class MajorcontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET5() {
        return MajorcontrollerApiFp.getAllUsingGET5()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET5(params: {  id: number; }) {
        return MajorcontrollerApiFp.getByIdUsingGET5(params)(this.fetch, this.basePath);
    }
};

/**
 * MajorcontrollerApi - factory interface
 */
export const MajorcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET5() {
            return MajorcontrollerApiFp.getAllUsingGET5()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET5(params: {  id: number; }) {
            return MajorcontrollerApiFp.getByIdUsingGET5(params)(fetch, basePath);
        },
    }
};


/**
 * PlanningcontrollerApi - fetch parameter creator
 */
export const PlanningcontrollerApiFetchParamCreactor = {
    /**
     * delete
     * @param id id
     */
    deleteUsingDELETE(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUsingDELETE");
        }
        const baseUrl = `/planning/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * generatePlanning
     */
    generatePlanningUsingGET(): FetchArgs {
        const baseUrl = `/planning/auto`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getAll
     */
    getAllUsingGET6(): FetchArgs {
        const baseUrl = `/planning`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET6(params: {  id?: number; }): FetchArgs {
        const baseUrl = `/planning/{id}`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "id": params.id,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * insertPlanning
     * @param planning planning
     */
    insertPlanningUsingPOST(params: {  planning: Planning; }): FetchArgs {
        // verify required parameter "planning" is set
        if (params["planning"] == null) {
            throw new Error("Missing required parameter planning when calling insertPlanningUsingPOST");
        }
        const baseUrl = `/planning`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["planning"]) {
            fetchOptions.body = JSON.stringify(params["planning"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * verifyConstraints
     * @param planning planning
     */
    verifyConstraintsUsingPOST(params: {  planning: Planning; }): FetchArgs {
        // verify required parameter "planning" is set
        if (params["planning"] == null) {
            throw new Error("Missing required parameter planning when calling verifyConstraintsUsingPOST");
        }
        const baseUrl = `/planning/verify`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["planning"]) {
            fetchOptions.body = JSON.stringify(params["planning"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PlanningcontrollerApi - functional programming interface
 */
export const PlanningcontrollerApiFp = {
    /**
     * delete
     * @param id id
     */
    deleteUsingDELETE(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PlanningcontrollerApiFetchParamCreactor.deleteUsingDELETE(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * generatePlanning
     */
    generatePlanningUsingGET(): (fetch: FetchAPI, basePath?: string) => Promise<Planning> {
        const fetchArgs = PlanningcontrollerApiFetchParamCreactor.generatePlanningUsingGET();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getAll
     */
    getAllUsingGET6(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Planning>> {
        const fetchArgs = PlanningcontrollerApiFetchParamCreactor.getAllUsingGET6();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET6(params: { id?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalPlanning> {
        const fetchArgs = PlanningcontrollerApiFetchParamCreactor.getByIdUsingGET6(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * insertPlanning
     * @param planning planning
     */
    insertPlanningUsingPOST(params: { planning: Planning;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PlanningcontrollerApiFetchParamCreactor.insertPlanningUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * verifyConstraints
     * @param planning planning
     */
    verifyConstraintsUsingPOST(params: { planning: Planning;  }): (fetch: FetchAPI, basePath?: string) => Promise<ScoreExplanationTimeTableOptaPlanerHardSoftScore> {
        const fetchArgs = PlanningcontrollerApiFetchParamCreactor.verifyConstraintsUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PlanningcontrollerApi - object-oriented interface
 */
export class PlanningcontrollerApi extends BaseAPI {
    /**
     * delete
     * @param id id
     */
    deleteUsingDELETE(params: {  id: number; }) {
        return PlanningcontrollerApiFp.deleteUsingDELETE(params)(this.fetch, this.basePath);
    }
    /**
     * generatePlanning
     */
    generatePlanningUsingGET() {
        return PlanningcontrollerApiFp.generatePlanningUsingGET()(this.fetch, this.basePath);
    }
    /**
     * getAll
     */
    getAllUsingGET6() {
        return PlanningcontrollerApiFp.getAllUsingGET6()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET6(params: {  id?: number; }) {
        return PlanningcontrollerApiFp.getByIdUsingGET6(params)(this.fetch, this.basePath);
    }
    /**
     * insertPlanning
     * @param planning planning
     */
    insertPlanningUsingPOST(params: {  planning: Planning; }) {
        return PlanningcontrollerApiFp.insertPlanningUsingPOST(params)(this.fetch, this.basePath);
    }
    /**
     * verifyConstraints
     * @param planning planning
     */
    verifyConstraintsUsingPOST(params: {  planning: Planning; }) {
        return PlanningcontrollerApiFp.verifyConstraintsUsingPOST(params)(this.fetch, this.basePath);
    }
};

/**
 * PlanningcontrollerApi - factory interface
 */
export const PlanningcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * delete
         * @param id id
         */
        deleteUsingDELETE(params: {  id: number; }) {
            return PlanningcontrollerApiFp.deleteUsingDELETE(params)(fetch, basePath);
        },
        /**
         * generatePlanning
         */
        generatePlanningUsingGET() {
            return PlanningcontrollerApiFp.generatePlanningUsingGET()(fetch, basePath);
        },
        /**
         * getAll
         */
        getAllUsingGET6() {
            return PlanningcontrollerApiFp.getAllUsingGET6()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET6(params: {  id?: number; }) {
            return PlanningcontrollerApiFp.getByIdUsingGET6(params)(fetch, basePath);
        },
        /**
         * insertPlanning
         * @param planning planning
         */
        insertPlanningUsingPOST(params: {  planning: Planning; }) {
            return PlanningcontrollerApiFp.insertPlanningUsingPOST(params)(fetch, basePath);
        },
        /**
         * verifyConstraints
         * @param planning planning
         */
        verifyConstraintsUsingPOST(params: {  planning: Planning; }) {
            return PlanningcontrollerApiFp.verifyConstraintsUsingPOST(params)(fetch, basePath);
        },
    }
};


/**
 * PrecedenceconstraintcontrollerApi - fetch parameter creator
 */
export const PrecedenceconstraintcontrollerApiFetchParamCreactor = {
    /**
     * deleteAll
     * @param ids ids
     */
    deleteAllUsingPOST(params: {  ids: Array<number>; }): FetchArgs {
        // verify required parameter "ids" is set
        if (params["ids"] == null) {
            throw new Error("Missing required parameter ids when calling deleteAllUsingPOST");
        }
        const baseUrl = `/constraints/precedence/delete`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["ids"]) {
            fetchOptions.body = JSON.stringify(params["ids"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getAll
     */
    getAllUsingGET7(): FetchArgs {
        const baseUrl = `/constraints/precedence`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * insertAll
     * @param constraints constraints
     */
    insertAllUsingPOST(params: {  constraints: Array<PrecedenceConstraint>; }): FetchArgs {
        // verify required parameter "constraints" is set
        if (params["constraints"] == null) {
            throw new Error("Missing required parameter constraints when calling insertAllUsingPOST");
        }
        const baseUrl = `/constraints/precedence`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["constraints"]) {
            fetchOptions.body = JSON.stringify(params["constraints"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PrecedenceconstraintcontrollerApi - functional programming interface
 */
export const PrecedenceconstraintcontrollerApiFp = {
    /**
     * deleteAll
     * @param ids ids
     */
    deleteAllUsingPOST(params: { ids: Array<number>;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PrecedenceconstraintcontrollerApiFetchParamCreactor.deleteAllUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getAll
     */
    getAllUsingGET7(): (fetch: FetchAPI, basePath?: string) => Promise<Array<PrecedenceConstraint>> {
        const fetchArgs = PrecedenceconstraintcontrollerApiFetchParamCreactor.getAllUsingGET7();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * insertAll
     * @param constraints constraints
     */
    insertAllUsingPOST(params: { constraints: Array<PrecedenceConstraint>;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PrecedenceconstraintcontrollerApiFetchParamCreactor.insertAllUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PrecedenceconstraintcontrollerApi - object-oriented interface
 */
export class PrecedenceconstraintcontrollerApi extends BaseAPI {
    /**
     * deleteAll
     * @param ids ids
     */
    deleteAllUsingPOST(params: {  ids: Array<number>; }) {
        return PrecedenceconstraintcontrollerApiFp.deleteAllUsingPOST(params)(this.fetch, this.basePath);
    }
    /**
     * getAll
     */
    getAllUsingGET7() {
        return PrecedenceconstraintcontrollerApiFp.getAllUsingGET7()(this.fetch, this.basePath);
    }
    /**
     * insertAll
     * @param constraints constraints
     */
    insertAllUsingPOST(params: {  constraints: Array<PrecedenceConstraint>; }) {
        return PrecedenceconstraintcontrollerApiFp.insertAllUsingPOST(params)(this.fetch, this.basePath);
    }
};

/**
 * PrecedenceconstraintcontrollerApi - factory interface
 */
export const PrecedenceconstraintcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * deleteAll
         * @param ids ids
         */
        deleteAllUsingPOST(params: {  ids: Array<number>; }) {
            return PrecedenceconstraintcontrollerApiFp.deleteAllUsingPOST(params)(fetch, basePath);
        },
        /**
         * getAll
         */
        getAllUsingGET7() {
            return PrecedenceconstraintcontrollerApiFp.getAllUsingGET7()(fetch, basePath);
        },
        /**
         * insertAll
         * @param constraints constraints
         */
        insertAllUsingPOST(params: {  constraints: Array<PrecedenceConstraint>; }) {
            return PrecedenceconstraintcontrollerApiFp.insertAllUsingPOST(params)(fetch, basePath);
        },
    }
};


/**
 * ProfessorcontrollerApi - fetch parameter creator
 */
export const ProfessorcontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET8(): FetchArgs {
        const baseUrl = `/professors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET7(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getByIdUsingGET7");
        }
        const baseUrl = `/professors/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ProfessorcontrollerApi - functional programming interface
 */
export const ProfessorcontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET8(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Professor>> {
        const fetchArgs = ProfessorcontrollerApiFetchParamCreactor.getAllUsingGET8();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET7(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalProfessor> {
        const fetchArgs = ProfessorcontrollerApiFetchParamCreactor.getByIdUsingGET7(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ProfessorcontrollerApi - object-oriented interface
 */
export class ProfessorcontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET8() {
        return ProfessorcontrollerApiFp.getAllUsingGET8()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param id id
     */
    getByIdUsingGET7(params: {  id: number; }) {
        return ProfessorcontrollerApiFp.getByIdUsingGET7(params)(this.fetch, this.basePath);
    }
};

/**
 * ProfessorcontrollerApi - factory interface
 */
export const ProfessorcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET8() {
            return ProfessorcontrollerApiFp.getAllUsingGET8()(fetch, basePath);
        },
        /**
         * getById
         * @param id id
         */
        getByIdUsingGET7(params: {  id: number; }) {
            return ProfessorcontrollerApiFp.getByIdUsingGET7(params)(fetch, basePath);
        },
    }
};


/**
 * RegistercontrollerApi - fetch parameter creator
 */
export const RegistercontrollerApiFetchParamCreactor = {
    /**
     * registerNewUser
     * @param user user
     */
    registerNewUserUsingPOST(params: {  user: User; }): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling registerNewUserUsingPOST");
        }
        const baseUrl = `/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * RegistercontrollerApi - functional programming interface
 */
export const RegistercontrollerApiFp = {
    /**
     * registerNewUser
     * @param user user
     */
    registerNewUserUsingPOST(params: { user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = RegistercontrollerApiFetchParamCreactor.registerNewUserUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RegistercontrollerApi - object-oriented interface
 */
export class RegistercontrollerApi extends BaseAPI {
    /**
     * registerNewUser
     * @param user user
     */
    registerNewUserUsingPOST(params: {  user: User; }) {
        return RegistercontrollerApiFp.registerNewUserUsingPOST(params)(this.fetch, this.basePath);
    }
};

/**
 * RegistercontrollerApi - factory interface
 */
export const RegistercontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * registerNewUser
         * @param user user
         */
        registerNewUserUsingPOST(params: {  user: User; }) {
            return RegistercontrollerApiFp.registerNewUserUsingPOST(params)(fetch, basePath);
        },
    }
};


/**
 * RoomcontrollerApi - fetch parameter creator
 */
export const RoomcontrollerApiFetchParamCreactor = {
    /**
     * getAll
     */
    getAllUsingGET9(): FetchArgs {
        const baseUrl = `/rooms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getById
     * @param roomId roomId
     */
    getByIdUsingGET8(params: {  roomId: number; }): FetchArgs {
        // verify required parameter "roomId" is set
        if (params["roomId"] == null) {
            throw new Error("Missing required parameter roomId when calling getByIdUsingGET8");
        }
        const baseUrl = `/rooms/{id}`
            .replace(`{${"roomId"}}`, `${ params.roomId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * RoomcontrollerApi - functional programming interface
 */
export const RoomcontrollerApiFp = {
    /**
     * getAll
     */
    getAllUsingGET9(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Room>> {
        const fetchArgs = RoomcontrollerApiFetchParamCreactor.getAllUsingGET9();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getById
     * @param roomId roomId
     */
    getByIdUsingGET8(params: { roomId: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<OptionalRoom> {
        const fetchArgs = RoomcontrollerApiFetchParamCreactor.getByIdUsingGET8(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RoomcontrollerApi - object-oriented interface
 */
export class RoomcontrollerApi extends BaseAPI {
    /**
     * getAll
     */
    getAllUsingGET9() {
        return RoomcontrollerApiFp.getAllUsingGET9()(this.fetch, this.basePath);
    }
    /**
     * getById
     * @param roomId roomId
     */
    getByIdUsingGET8(params: {  roomId: number; }) {
        return RoomcontrollerApiFp.getByIdUsingGET8(params)(this.fetch, this.basePath);
    }
};

/**
 * RoomcontrollerApi - factory interface
 */
export const RoomcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * getAll
         */
        getAllUsingGET9() {
            return RoomcontrollerApiFp.getAllUsingGET9()(fetch, basePath);
        },
        /**
         * getById
         * @param roomId roomId
         */
        getByIdUsingGET8(params: {  roomId: number; }) {
            return RoomcontrollerApiFp.getByIdUsingGET8(params)(fetch, basePath);
        },
    }
};


/**
 * RootcontrollerApi - fetch parameter creator
 */
export const RootcontrollerApiFetchParamCreactor = {
    /**
     * helloWorld
     */
    helloWorldUsingGET(): FetchArgs {
        const baseUrl = `/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * RootcontrollerApi - functional programming interface
 */
export const RootcontrollerApiFp = {
    /**
     * helloWorld
     */
    helloWorldUsingGET(): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = RootcontrollerApiFetchParamCreactor.helloWorldUsingGET();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RootcontrollerApi - object-oriented interface
 */
export class RootcontrollerApi extends BaseAPI {
    /**
     * helloWorld
     */
    helloWorldUsingGET() {
        return RootcontrollerApiFp.helloWorldUsingGET()(this.fetch, this.basePath);
    }
};

/**
 * RootcontrollerApi - factory interface
 */
export const RootcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * helloWorld
         */
        helloWorldUsingGET() {
            return RootcontrollerApiFp.helloWorldUsingGET()(fetch, basePath);
        },
    }
};


/**
 * TimeconstraintcontrollerApi - fetch parameter creator
 */
export const TimeconstraintcontrollerApiFetchParamCreactor = {
    /**
     * deleteAll
     * @param ids ids
     */
    deleteAllUsingPOST1(params: {  ids: Array<number>; }): FetchArgs {
        // verify required parameter "ids" is set
        if (params["ids"] == null) {
            throw new Error("Missing required parameter ids when calling deleteAllUsingPOST1");
        }
        const baseUrl = `/constraints/time-and-room/delete`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["ids"]) {
            fetchOptions.body = JSON.stringify(params["ids"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * getAll
     */
    getAllUsingGET10(): FetchArgs {
        const baseUrl = `/constraints/time-and-room`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * insertAll
     * @param constraints constraints
     */
    insertAllUsingPOST1(params: {  constraints: Array<TimeConstraint>; }): FetchArgs {
        // verify required parameter "constraints" is set
        if (params["constraints"] == null) {
            throw new Error("Missing required parameter constraints when calling insertAllUsingPOST1");
        }
        const baseUrl = `/constraints/time-and-room`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["constraints"]) {
            fetchOptions.body = JSON.stringify(params["constraints"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * TimeconstraintcontrollerApi - functional programming interface
 */
export const TimeconstraintcontrollerApiFp = {
    /**
     * deleteAll
     * @param ids ids
     */
    deleteAllUsingPOST1(params: { ids: Array<number>;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeconstraintcontrollerApiFetchParamCreactor.deleteAllUsingPOST1(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * getAll
     */
    getAllUsingGET10(): (fetch: FetchAPI, basePath?: string) => Promise<Array<TimeConstraint>> {
        const fetchArgs = TimeconstraintcontrollerApiFetchParamCreactor.getAllUsingGET10();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * insertAll
     * @param constraints constraints
     */
    insertAllUsingPOST1(params: { constraints: Array<TimeConstraint>;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeconstraintcontrollerApiFetchParamCreactor.insertAllUsingPOST1(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TimeconstraintcontrollerApi - object-oriented interface
 */
export class TimeconstraintcontrollerApi extends BaseAPI {
    /**
     * deleteAll
     * @param ids ids
     */
    deleteAllUsingPOST1(params: {  ids: Array<number>; }) {
        return TimeconstraintcontrollerApiFp.deleteAllUsingPOST1(params)(this.fetch, this.basePath);
    }
    /**
     * getAll
     */
    getAllUsingGET10() {
        return TimeconstraintcontrollerApiFp.getAllUsingGET10()(this.fetch, this.basePath);
    }
    /**
     * insertAll
     * @param constraints constraints
     */
    insertAllUsingPOST1(params: {  constraints: Array<TimeConstraint>; }) {
        return TimeconstraintcontrollerApiFp.insertAllUsingPOST1(params)(this.fetch, this.basePath);
    }
};

/**
 * TimeconstraintcontrollerApi - factory interface
 */
export const TimeconstraintcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * deleteAll
         * @param ids ids
         */
        deleteAllUsingPOST1(params: {  ids: Array<number>; }) {
            return TimeconstraintcontrollerApiFp.deleteAllUsingPOST1(params)(fetch, basePath);
        },
        /**
         * getAll
         */
        getAllUsingGET10() {
            return TimeconstraintcontrollerApiFp.getAllUsingGET10()(fetch, basePath);
        },
        /**
         * insertAll
         * @param constraints constraints
         */
        insertAllUsingPOST1(params: {  constraints: Array<TimeConstraint>; }) {
            return TimeconstraintcontrollerApiFp.insertAllUsingPOST1(params)(fetch, basePath);
        },
    }
};


/**
 * UsercontrollerApi - fetch parameter creator
 */
export const UsercontrollerApiFetchParamCreactor = {
    /**
     * deleteUser
     * @param id id
     */
    deleteUserUsingDELETE(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserUsingDELETE");
        }
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "id": params.id,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * updateUser
     * @param name name
     * @param firstname firstname
     * @param email email
     * @param id id
     * @param isAdmin isAdmin
     */
    updateUserUsingPOST(params: {  name: string; firstname: string; email: string; id: number; isAdmin: boolean; }): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateUserUsingPOST");
        }
        // verify required parameter "firstname" is set
        if (params["firstname"] == null) {
            throw new Error("Missing required parameter firstname when calling updateUserUsingPOST");
        }
        // verify required parameter "email" is set
        if (params["email"] == null) {
            throw new Error("Missing required parameter email when calling updateUserUsingPOST");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserUsingPOST");
        }
        // verify required parameter "isAdmin" is set
        if (params["isAdmin"] == null) {
            throw new Error("Missing required parameter isAdmin when calling updateUserUsingPOST");
        }
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "name": params.name,
            "firstname": params.firstname,
            "email": params.email,
            "id": params.id,
            "isAdmin": params.isAdmin,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * UsercontrollerApi - functional programming interface
 */
export const UsercontrollerApiFp = {
    /**
     * deleteUser
     * @param id id
     */
    deleteUserUsingDELETE(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsercontrollerApiFetchParamCreactor.deleteUserUsingDELETE(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * updateUser
     * @param name name
     * @param firstname firstname
     * @param email email
     * @param id id
     * @param isAdmin isAdmin
     */
    updateUserUsingPOST(params: { name: string; firstname: string; email: string; id: number; isAdmin: boolean;  }): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UsercontrollerApiFetchParamCreactor.updateUserUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsercontrollerApi - object-oriented interface
 */
export class UsercontrollerApi extends BaseAPI {
    /**
     * deleteUser
     * @param id id
     */
    deleteUserUsingDELETE(params: {  id: number; }) {
        return UsercontrollerApiFp.deleteUserUsingDELETE(params)(this.fetch, this.basePath);
    }
    /**
     * updateUser
     * @param name name
     * @param firstname firstname
     * @param email email
     * @param id id
     * @param isAdmin isAdmin
     */
    updateUserUsingPOST(params: {  name: string; firstname: string; email: string; id: number; isAdmin: boolean; }) {
        return UsercontrollerApiFp.updateUserUsingPOST(params)(this.fetch, this.basePath);
    }
};

/**
 * UsercontrollerApi - factory interface
 */
export const UsercontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * deleteUser
         * @param id id
         */
        deleteUserUsingDELETE(params: {  id: number; }) {
            return UsercontrollerApiFp.deleteUserUsingDELETE(params)(fetch, basePath);
        },
        /**
         * updateUser
         * @param name name
         * @param firstname firstname
         * @param email email
         * @param id id
         * @param isAdmin isAdmin
         */
        updateUserUsingPOST(params: {  name: string; firstname: string; email: string; id: number; isAdmin: boolean; }) {
            return UsercontrollerApiFp.updateUserUsingPOST(params)(fetch, basePath);
        },
    }
};

